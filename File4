sp_who2
SELECT *FROM sys.dm_db_missing_index_details
-- Database is not fragmented-- The list of Tables , Indexes and the rows in the tables
-- This query will give you a list of all table names with there index names -- and the number of rows in it-- depending on the number of rows , select the tablename and index and -- run dbcc showcontig on the table/index name
select b.name as TableName,a.name as IndexName, a.rows as NoOfRows from sysindexes a inner join sysobjects b on a.id = b.idorder by rows desc
--Drop Database--use master
--alter database DBName set single_user with rollback immediate
--restore database DBName ...
--alter database DBName set multi_user
-- Then attempt to take your database to multi_user mode, do this from masterUSE MASTER GO
ALTER DATABASE myDatabaseName SET multi_user WITH ROLLBACK IMMEDIATEGO
-- Now put it into single_user mode and drop it. Use Rollback Immediate to disconnect any sessions and rollback their transactions. Safe since you are about to drop the DB.ALTER DATABASE myDatabaseNameSET SINGLE_USER WITH ROLLBACK IMMEDIATEGO
DROP DATABASE myDatabaseNameGOemfmlfmds:F
----- Find a list of index on respective databaseselect T.name as TableName, I.name as IndexName, AC.Name as ColumnName, I.type_desc as IndexType from sys.tables as T inner join sys.indexes as I on T.[object_id] = I.[object_id]    inner join sys.index_columns as IC on IC.[object_id] = I.[object_id] and IC.[index_id] = I.[index_id]    inner join sys.all_columns as AC on IC.[object_id] = AC.[object_id] and IC.[column_id] = AC.[column_id] order by T.name, I.name-----
-- Finding Index FragmentationSELECT ps.database_id, object_name((ps.OBJECT_ID)),ps.index_id, b.name,ps.avg_fragmentation_in_percentFROM sys.dm_db_index_physical_stats (DB_ID(), NULL, NULL, NULL, NULL) AS psINNER JOIN sys.indexes AS b ON ps.OBJECT_ID = b.OBJECT_IDAND ps.index_id = b.index_idWHERE ps.database_id = DB_ID()ORDER BY ps.OBJECT_ID
SELECT ps.database_id, object_name((ps.OBJECT_ID)),ps.index_id, b.name,ps.avg_fragmentation_in_percentFROM sys.dm_db_index_physical_stats (1, NULL, NULL, NULL, NULL) AS psINNER JOIN sys.indexes AS b ON ps.OBJECT_ID = b.OBJECT_IDAND ps.index_id = b.index_idWHERE ps.database_id = 1ORDER BY ps.OBJECT_ID
select * from sysdatabases
-- Latest Script to Find Rows in a TableSELECT sc.name +'.'+ ta.name TableName ,SUM(pa.rows) RowCnt FROM sys.tables ta INNER JOIN sys.partitions pa ON pa.OBJECT_ID = ta.OBJECT_ID INNER JOIN sys.schemas sc ON ta.schema_id = sc.schema_id WHERE ta.is_ms_shipped = 0 AND pa.index_id IN (1,0) GROUP BY sc.name,ta.name ORDER BY SUM(pa.rows) DESC
-- You can get individual row count from this query
-- Get a count of the no of rows in the table again select COUNT(*) from Employee
-- this command gives you a list of all indexes on the -- specified table 
sp_helpindex atstransacts
-- dbcc showcontig will give you if the indexes on a table are fragmented-- dbccc works with 2 parameters Tablename/Indexname-- If the scan density is < 90% then it means the indexes / database is fragmented-- run dbcc on atlest 4 different tables / Indexes
dbcc showcontig(atstransacts,PK_AtsTransacts)
-- To remeove fragmentation on a individual Tbale-- run the ALTER INDEX command -- ALTER INDEX on a specific table will rebuild al indexes on a gven table-- ALTER index should be run when there are no users logged in to the system-- ALTER index should be run on  aquite system-- run sp_who2 to find out all user processes running on the system
ALTER INDEX ALL ON Employee REBUILD
-- this is one more query which will give you list of tables and indexes
SELECT   DISTINCT SchemaName = schema_name(schema_id),            TableName = object_name(t.object_id),            ColumnList = Stuff((SELECT  ', ' + c1.Name AS [text()]                                     FROM sys.indexes i1            INNER JOIN sys.tables t1               ON i1.object_id = t1.object_id            INNER JOIN sys.index_columns ic1               ON ic1.object_id = t1.object_id                   AND ic1.index_id = i1.index_id            INNER JOIN sys.columns c1               ON c1.object_id = t1.object_id                   AND ic1.column_id = c1.column_id                                     WHERE t.schema_id = t1.schema_id                                            and t.object_id = t1.object_id                                            and i.name =i1.name                                    FOR XML PATH ('')),1,1,''),            IndexName = i.Name FROM      sys.indexes i            INNER JOIN sys.tables t               ON i.object_id = t.object_id            INNER JOIN sys.index_columns ic               ON ic.object_id = t.object_id                   AND ic.index_id = i.index_id            INNER JOIN sys.columns c               ON c.object_id = t.object_id                   AND ic.column_id = c.column_id ORDER BY SchemaName,            TableName,            IndexName
SELECT migs.avg_total_user_cost * (migs.avg_user_impact / 100.0) * (migs.user_seeks + migs.user_scans) AS improvement_measure,   'CREATE INDEX [missing_index_' + CONVERT (varchar, mig.index_group_handle) + '_' + CONVERT (varchar, mid.index_handle)   + '_' + LEFT (PARSENAME(mid.statement, 1), 32) + ']'  + ' ON ' + mid.statement   + ' (' + ISNULL (mid.equality_columns,'')     + CASE WHEN mid.equality_columns IS NOT NULL AND mid.inequality_columns IS NOT NULL THEN ',' ELSE '' END     + ISNULL (mid.inequality_columns, '')  + ')'   + ISNULL (' INCLUDE (' + mid.included_columns + ')', '') AS create_index_statement,   migs.*, mid.database_id, mid.[object_id]FROM sys.dm_db_missing_index_groups migINNER JOIN sys.dm_db_missing_index_group_stats migs ON migs.group_handle = mig.index_group_handleINNER JOIN sys.dm_db_missing_index_details mid ON mig.index_handle = mid.index_handleWHERE migs.avg_total_user_cost * (migs.avg_user_impact / 100.0) * (migs.user_seeks + migs.user_scans) > 10ORDER BY migs.avg_total_user_cost * migs.avg_user_impact * (migs.user_seeks + migs.user_scans) DESC
SELECT    o.name AS object_name, i.name AS index_name   , i.type_desc, u.user_seeks, u.user_scans, u.user_lookups, u.user_updatesFROM sys.indexes iJOIN sys.objects o ON  i.object_id = o.object_idLEFT JOIN  sys.dm_db_index_usage_stats u ON i.object_id = u.object_id          AND    i.index_id = u.index_id          AND    u.database_id = DB_ID()WHERE    o.type <> 'S'    and isnull(u.user_updates,0) > 0and i.type_desc <> 'HEAP'ORDER BY    (convert(decimal(19,4),ISNULL(u.user_seeks, 0)) + ISNULL(u.user_scans, 0) + ISNULL(u.user_lookups, 0))/ISNULL(u.user_updates, 0) asc, u.user_updates DESC
SELECT TOP 5 obj.name, max_logical_reads, max_elapsed_timeFROM sys.dm_exec_query_stats aCROSS APPLY sys.dm_exec_sql_text(sql_handle) hndINNER JOIN sys.sysobjects obj on hnd.objectid = obj.idORDER BY max_logical_reads DESC
SELECT TOP 10    total_worker_time/execution_count AS Avg_CPU_Time        ,execution_count        ,total_elapsed_time/execution_count as AVG_Run_Time        ,(SELECT              SUBSTRING(text,statement_start_offset/2,(CASE                                                           WHEN statement_end_offset = -1 THEN LEN(CONVERT(nvarchar(max), text)) * 2                                                            ELSE statement_end_offset                                                        END -statement_start_offset)/2                       ) FROM sys.dm_exec_sql_text(sql_handle)         ) AS query_text FROM sys.dm_exec_query_stats ORDER BY Avg_CPU_Time DESC
--http://stackoverflow.com/questions/2499910/how-to-find-the-worst-performing-queries-in-sql-server-2008--http://furrukhbaig.wordpress.com/category/dmvs/--http://furrukhbaig.wordpress.com/2007/08/17/worst-performing-queries/--http://www.simple-talk.com/sql/performance/finding-the-causes-of-poor-performance-in-sql-server,-part-1/--http://blog.sqlauthority.com/2010/09/13/sql-server-what-are-wait-types-wait-stats-and-its-importance/--http://technet.microsoft.com/en-us/library/cc768048.aspx--http://mcpmag.com/articles/2012/03/14/top-12-features-of-sql-server-2012.aspx--http://blogs.technet.com/b/canitpro/archive/2013/08/20/step-by-step-creating-a-sql-server-2012-alwayson-availability-group.aspx
SELECT *FROM sys.dm_os_wait_stats
------ unused tables & indexes.  Tables have index_id’s of either 0 = Heap table or 1 = Clustered IndexDeclare @dbid intSelect @dbid = db_id('Northwind')Select  objectname=object_name(i.object_id)                        , indexname=i.name, i.index_idfrom sys.indexes i, sys.objects owhere objectproperty(o.object_id,'IsUserTable') = 1and i.index_id NOT IN (select s.index_id       from sys.dm_db_index_usage_stats s               where s.object_id=i.object_id and                        i.index_id=s.index_id and                        database_id = @dbid )and o.object_id = i.object_idorder by objectname,i.index_id,indexname asc --Rarely used indexes will appear in sys.dm_db_index_usage_stats just like heavily used indexes.  To find rarely used indexes, you look at columns such as user_seeks, user_scans, user_lookups, and user_updates. --- rarely used indexes appear firstdeclare @dbid intselect @dbid = db_id()select objectname=object_name(s.object_id), s.object_id, indexname=i.name, i.index_id            , user_seeks, user_scans, user_lookups, user_updatesfrom sys.dm_db_index_usage_stats s,            sys.indexes iwhere database_id = @dbid and objectproperty(s.object_id,'IsUserTable') = 1and i.object_id = s.object_idand i.index_id = s.index_idorder by (user_seeks + user_scans + user_lookups + user_updates) asc
SELECT TOP 10    total_worker_time/execution_count AS Avg_CPU_Time        ,execution_count        ,total_elapsed_time/execution_count as AVG_Run_Time        ,(SELECT              SUBSTRING(text,statement_start_offset/2,(CASE                                                           WHEN statement_end_offset = -1 THEN LEN(CONVERT(nvarchar(max), text)) * 2                                                            ELSE statement_end_offset                                                        END -statement_start_offset)/2                       ) FROM sys.dm_exec_sql_text(sql_handle)         ) AS query_text FROM sys.dm_exec_query_stats 


sp_configure
-- If you already have a login id and password for this user, fix it by doing:-- EXEC sp_change_users_login 'Auto_Fix', 'user'

THE BEST SQL SERVER PERFORMANCE MONITOR COUNTERS TO ANALYZE
Now that you’ve got the hang of adding counters, here’s the full list we need to add, including the ones mentioned above:
These are listed OBJECT first, then COUNTERMemory – Available MBytesPaging File – % UsagePhysical Disk – Avg. Disk sec/ReadPhysical Disk – Avg. Disk sec/WritePhysical Disk – Disk Reads/secPhysical Disk – Disk Writes/secProcessor – % Processor TimeSQLServer: Buffer Manager – Page life expectancySQLServer: General Statistics – User ConnectionsSQLServer: Memory Manager – Memory Grants PendingSQLServer: SQL Statistics – Batch Requests/secSQLServer: SQL Statistics – Compilations/secSQLServer: SQL Statistics – Recompilations/secSystem – Processor Queue Length
< 8ms: excellent< 12ms: good< 20ms: fair> 20ms: poor
Snapshot AgentThe Snapshot Agent is typically used with all types of replication. It prepares schema and initial data files of published tables and other objects, stores the snapshot files, and records information about synchronization in the distribution database. The Snapshot Agent runs at the Distributor. For more information, see Replication Snapshot Agent.
Log Reader AgentThe Log Reader Agent is used with transactional replication. It moves transactions marked for replication from the transaction log on the Publisher to the distribution database. Each database published using transactional replication has its own Log Reader Agent that runs on the Distributor and connects to the Publisher (the Distributor can be on the same computer as the Publisher). For more information, see Replication Log Reader Agent.
Distribution AgentThe Distribution Agent is used with snapshot replication and transactional replication. It applies the initial snapshot to the Subscriber and moves transactions held in the distribution database to Subscribers. The Distribution Agent runs at either the Distributor for push subscriptions or at the Subscriber for pull subscriptions. For more information, see Replication Distribution Agent.
Merge AgentThe Merge Agent is used with merge replication. It applies the initial snapshot to the Subscriber and moves and reconciles incremental data changes that occur. Each merge subscription has its own Merge Agent that connects to both the Publisher and the Subscriber and updates both. The Merge Agent runs at either the Distributor for push subscriptions or the Subscriber for pull subscriptions. By default, the Merge Agent uploads changes from the Subscriber to the Publisher and then downloads changes from the Publisher to the Subscriber. For more information, see Replication Merge Agent.Queue Reader Agent
--The Bulk-Logged Recovery model provides protection against media failure combined with the best performance and minimal log space usage for certain large-scale or bulk copy operations. These operations are minimally logged:--SELECT INTO.
Bulk load operations (bcp and BULK INSERT).
CREATE INDEX (including indexed views).
--text and image operations (WRITETEXT and UPDATETEXT).--In a Bulk-Logged Recovery model, the data loss exposure for these bulk copy operations is greater than in the Full Recovery model. --While the bulk copy operations are fully logged under the Full Recovery model, they are minimally logged and cannot be controlled on an --operation-by-operation basis under the Bulk-Logged Recovery model. Under the Bulk-Logged Recovery model, a damaged data file can result in having to redo work manually.--In addition, the Bulk-Logged Recovery model only allows the database to be recovered to the end of a transaction log backup when the log backup --contains bulk changes. Point-in-time recovery is not supported.--In Microsoft® SQL Server™ 2000, you can switch between full and bulk-logged recovery models easily. It is not necessary to perform a full database backup --after bulk copy operations complete under the Bulk-Logged Recovery model. Transaction log backups under this model capture both the log and --the results of any bulk operations performed since the last backup.--The backup strategy for bulk-logged recovery consists of:--Database backups.
-- http://www.mssqltips.com/sqlservertutorial/5/sql-server-bulklogged-recovery-model/
Differential backups (optional).
Log backups.Backing up a log that contains bulk-logged operations requires access to all data files in the database. If the data files are not accessible, the final transaction log cannot be backed up and all committed operations in that log will be lost.
sp_who2 'active'
dbcc inputbuffer(15)
